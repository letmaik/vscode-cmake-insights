<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1, maximum-scale=1">

  <script src="https://d3js.org/d3.v4.min.js"></script>

  <script src="https://unpkg.com/dagre@0.7.4/dist/dagre.js"></script>
  <!--<script src="https://unpkg.com/dagre-d3@0.6.3/dist/dagre-d3.min.js"></script>-->
  <script src="https://unpkg.com/dagre-d3@0.6.3/dist/dagre-d3.js"></script>

  <script src="https://unpkg.com/popper.js@1.15.0/dist/umd/popper.min.js"></script>
  <script src="https://unpkg.com/tippy.js@4.2.1/umd/index.all.min.js"></script>
  
  <script src="https://unpkg.com/moment@2.14.1/min/moment.min.js"></script>

  <style>
    body.vscode-light,
    body.vscode-dark {
      color: gray;
    }

    body.vscode-high-contrast {
      color: white;
    }

    code {
      font-family: var(--vscode-editor-font-family);
      font-weight: var(--vscode-editor-font-weight);
    }

    #extra-info {
      position: absolute;
      bottom: 0;
    }

    td {
      text-align: left;
      vertical-align: top;
    }

    #graph {
      width: 100%;
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 999;
    }
  </style>

  <style id="dagre-d3-style">
    .node rect {
      stroke: #333;
      fill: #fff;
    }

    .node.type-EXECUTABLE rect {
      fill: #C83E25;
    }

    .node.type-STATIC_LIBRARY rect {
      fill: #37A35C;
    }

    .node.type-OBJECT_LIBRARY rect {
      fill: #37A35C;
      stroke: gray;
      stroke-width: 3;
      stroke-dasharray: 5;
    }

    .node.type-SHARED_LIBRARY rect {
      fill: #33758B;
    }

    .node.type-MODULE_LIBRARY rect {
      fill: #33758B;
    }

    .node.type-UTILITY rect {
      fill: #707070;
    }

    .cluster rect {
      fill: none;
      stroke-width: 2;
      stroke: red;
    }

    .edgePath path {
      stroke: gray;
      fill: gray;
      stroke-width: 2;
    }

    .node text, .cluster text {
      pointer-events: none;
      fill: rgb(230, 230, 230);
      font-family: 'Segoe UI';
    }
  </style>

  <script>
    let cmakeData = ["%DATA%"];

    function ignoreTarget(target) {
      return target.isGeneratorProvided
    }

    const projectPrefix = '__PROJ_';

    const targetMap = {};
    for (let target of cmakeData.targets) {
      targetMap[target.id] = target;
    }

    const filteredTargets = cmakeData.targets.filter(t => !ignoreTarget(t));
    const projectIdxs = new Set(filteredTargets.map(t => t.projectIndex));
    const showProjectCompoundNodes = projectIdxs.size > 1;

    const nodes = filteredTargets.map(target => {
      if (showProjectCompoundNodes) {
        target.parent = projectPrefix + target.projectIndex.toString();
      }
      return target
    });
    
    if (showProjectCompoundNodes) {
      for (const projectIdx of projectIdxs) {
        nodes.push({
          type: 'project',
          id: projectPrefix + projectIdx.toString(),
          name: cmakeData.projectNames[projectIdx]
        });
      }
    }

    const edges = [];
    for (const target of filteredTargets) {
      for (const depId of target.dependencies) {
        if (ignoreTarget(targetMap[depId])) continue;
        edges.push({
          source: target.id, target: depId
        });
      }
    }

    window.addEventListener('DOMContentLoaded', function () {
      function showDataAge() {
        const created = moment(cmakeData.created);
        const now = moment();
        const age = moment.duration(now.diff(created));
        let ageText;
        if (age.asSeconds() > 60) {
          ageText = age.humanize() + ' old'
        } else {
          ageText = 'up-to-date'
        }
        document.getElementById('extra-info').innerHTML = 
          'API Data: ' + ageText;
      }
      showDataAge();
      setInterval(showDataAge, 10000);

      var g = new dagreD3.graphlib.Graph({ compound: true }).setGraph({});
      g.setDefaultEdgeLabel(function() { return {curve: d3.curveBasis}; });

      for (const node of nodes) {
        g.setNode(node.id, {label: node.name, class: "type-" + node.type, clusterLabelPos: 'top', data: node});
        if (node.parent) {
          g.setParent(node.id, node.parent);
        }
      }

      for (const edge of edges) {
        g.setEdge(edge.source, edge.target);
      }

      const svg = d3.select("#graph");
      svg.attr("width", window.innerWidth)
         .attr("height", window.innerHeight);
      const inner = svg.append("g");

      var zoom = d3.zoom().on("zoom", () => {
        inner.attr("transform", d3.event.transform);
      });
      svg.call(zoom);

      // TODO highlight connected edges when tapping/holding node

      const render = new dagreD3.render();
      render(inner, g);

      var initialScale = 1.0;
      var offsetX = (svg.attr("width") - g.graph().width * initialScale) / 2;
      var offsetY = (svg.attr("height") - g.graph().height * initialScale) / 2;
      svg.call(zoom.transform, d3.zoomIdentity.translate(offsetX, offsetY).scale(initialScale));

      const typeLabels = {
        'STATIC_LIBRARY': 'Static Library',
        'SHARED_LIBRARY': 'Shared Library',
        'MODULE_LIBRARY': 'Module Library',
        'OBJECT_LIBRARY': 'Object Library',
        'UTILITY': 'Utility',
        'EXECUTABLE': 'Executable',
      }

      const languageLabels = {
        'CXX': 'C++'
      }

      function getTooltipContent(data) {
        const typeLabel = typeLabels[data.type];
        let languages = data.languages.map(l => languageLabels[l] || l).join(', ');
        if (languages) {
          languages = ' (' + languages + ')';
        }
        let text = '<strong>' + typeLabel + languages + '</strong><br><br>';
        text += '<table>';
        text += '<tr><td>Definition:</td><td>' + data.definition + '</td><tr>';
        if (data.nameOnDisk) {
          text += '<tr><td>Filename:</td><td>' + data.nameOnDisk + '</td></tr>';
        }
        if (data.sources.length > 0) {
          text += "<tr><td>Sources:</td><td>";
          const filteredSources = data.sources.filter(s => !s.fromObjectLibrary);
          const sources = filteredSources.slice(0, 10);
          text += sources.map(s => (s.isGenerated ? '<i>' : '') + s.path + (s.isGenerated ? '</i>' : '')).join('<br>');
          const remaining = filteredSources.length - sources.length;
          if (remaining > 0) {
            text += '<br> (' + remaining.toString() + ' more...)';
          }
          text += '</td></tr>';
        }
        text += '</table>';
        return text;
      }

      inner.selectAll("g.node").each(v => { 
        const node = g.node(v);
        const data = node.data
        if (data.type == 'project') {
          return;
        }
        const text = getTooltipContent(data);

        tippy(node.elem, {
          content: text,
          animation: 'fade',
          arrow: true,
        });
      });
    });
  </script>
</head>

<body>
  <p>
    Note: <code>INTERFACE</code> and <code>IMPORTED</code> targets are not displayed.
  </p>
  <p id="extra-info"></p>
  <svg id="graph"></svg>
</body>

</html>